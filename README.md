# 자이카 차선인식 자율주행 프로젝트

### 시작 일시 및 참고 사항
- 2021 / 04 / 04 ~ 2021 / 04 / 08 (총 5일)
- 프로그래머스 강의장에 준비되어있는 라인을 따라 차량을 주행시킴.
- 차선 인식 알고리즘을 이용하여 차선을 파악 한 후, 적절한 제어를 통해서 완주 시키는 것이 목표
***

### 1일차 내용
- 실제로 어떤 차선주행 알고리즘을 이용하여 차선을 인식시킬지에 대한 논의를 수행함.
- 프로그래머스에서 가르쳐주었던 허프만 라인 검색 방법과 슬라이딩 윈도우를 사용한 라인 검색을 생각하였음.
- 자이카의 동작을 알아보기 위해서 단순한 line_drive 및 hough_drive를 ROS에서 사용 할 수 있게 커스터마이징 하였음.
- 그 결과, 허프만을 통해 감지된 라인의 중앙과 카메라 중앙값과의 차이를 이용하여 각도를 결정 하는 것을 알 수 있었음.
- 라인 드라이브의 경우, HSV를 통한 (그레이 스케일 변환을 통해 V 검출) 라인 검출과 라인의 중앙과 카메라의 중앙값을 차이로 각도를 결정함을 알 수 있었음.
- 어떠한 알고리즘을 쓸지 회의 한 결과, 아직 공부를 제대로 하지 못했던 윈도우 슬라이딩을 사용하여 공부하면서 알고리즘을 코딩하기로 결정함.
***

### 2일차 내용
- 프로그래머스에서 제공한 슬라이드 윈도우 인식 파일을 ROS화 시키는 작업을 수행하였음.
- 하지만, 실제로 사용하려니 마스크의 크기가 애매하였기 때문에, 수작업으로 마스크 변경 작업을 하였음.
- 슬라이드 윈도우를 이용하여 라인을 검출 하였지만, 제어 부분을 어떻게 해야할 지에 대해서 토의 하였음.
- 하지만, 차선을 제외한 나머지가 흰색이 됨을 확인 하였음. => bitwise_and를 사용하여 검은색으로 변환하거나, 임계값을 반대로 뒤집으면 됨.
- 간단하게 계산한다면, 라인의 중앙과 카메라 중앙값의 차이로 제어 할 수 있었지만, 정밀하게 주행시키고 싶었음.
- 제어에 관한 내용은 각자 수학적인 계산 방법들을 조사해오기로 하였음.
***

### 3일차 내용
- 윈도우 슬라이드에서 나오는 곡선에 대해서 제어하기 위해 Curvature of Radius 공식을 이용하기로 하였음.
- Curvature of Radius 공식은 매우 복잡하지만, 피타고라스의 법칙을 사용하면 간결하게 사용 할 수 있었음.
- 하지만, 우리가 구해진 값은 픽셀 단위이기 때문에 Pixel to Meter 변환이 필요하였음. -> 실제로 카메라에 물체를 재서 값을 도출함.
- 이를 통해 나오는 각도를 PID 제어를 수행하기 위해 코드를 작성하였음.
- 실제 코드 안에서 슬라이딩 윈도우 검출에서 선이 1개만 추출 될 경우 선형적인 결과가 나오지 못하는 문제가 발생함.
- 이전 x값과 다음 x값에 대한 상관관계가 없음을 확인하여 슬라이딩 윈도우를 직접적으로 수정하기로 하였음.
- 추가적으로, 카메라 캘리브레이션이 제대로 되지 않아서 추가적인 캘리브레이션을 수행하였음.
- HLS의 이진화 작업이 제대로 되지 않아 고정적인 임계값을 주었기 때문에 개선을해야 한다는 것을 인지하였음.
***

### 4일차 내용
- 최적의 마스크와 PID 제어가 된 값이 형상관리가 되지 않아 날라가버렸음...
- 앞으로는 Git을 제대로 활용하여 역할 분담과 버전관리를 해야한다는 것을 배울 수 있었음.
- 캘리브레이션을 조정했기 때문에 슬라이딩 윈도우 팀은 마스크 작업을 지속하면서 최적의 위치를 BEV를 수행함. (Bird eye view)
- Curvature of Radius 값이 선형적이지 않아 PID 제어가 잘 되지 않아서 Pixel to Meter의 문제라 생각하여 배제 하였음.
- 버드아이즈뷰가 320 x 240이었는데, 두배로 늘려서 좀 더 선형적인 값이 도출되도록 코드를 변형하였음.
- Curvature of Radius 값이 픽셀로 다시 바뀌는 바람에 PID를 다시 시작하게 되었음.
- 슬라이딩 윈도우 선이 1개가 검출 되었을 때에 대한 예외처리를 하기 시작함.
***

### 5일차 내용
- 슬라이딩 윈도우 선이 1개가 검출 되었을 때에 대한 예외처리가 되지 않았지만, 그래도 유도하던 대로 값이 나왔음. (왼쪽과 오른쪽이 합쳐져서 1개로 나옴)
- 이상적인 버드아이즈뷰에서는 잘 되는 것을 확인 하였음. 단, 완전히 휘어버린 곡선은 아직도 문제가 있음을 발견함.
- 너무 많이 코드가 바뀌는 바람에, 주행할 수 없는 수준이 되어버렸음.
- 2차 선형 계산식이 잘못 됐다고 생각하여 1차 선형 계산식으로 변경하였음.
- 1차 선형 계산식은 곡선에서 강하고 직선에서 약한 모습을 보였고, 2차 선형 계산식에서는 직선이 강하고 곡선이 약한 결과를 보였음.
- 최종적으로는 주행 불가로 판단되어 경진대회를 불참하게 됨.
***

### 프로젝트 실패 원인 분석
- 기간이 너무 짧았다.
- 프로그래머스에서 제공한 코드를 너무 믿고 사용한 잘못도 있었음.
- 이미지 프로세싱 전처리 과정(필터)을 미흡하게 하였기 때문에, 이진 값이 너무 튀었음.
- 2개의 차선이 보일 때는 안정적이었지만, 1개의 차선만 보였을 때 어떻게 처리 해야하는지에 대해 너무 깊게 생각하였음.
- 수학적인 계산식이 픽셀 단위로 계산되다 보니, 오차가 더욱 커졌다고 생각 됨.
- Git을 이용한 버전관리, 프로젝트에 대한 역할 분담, 제공된 코드에 대한 사전 지식이 미흡하였음.
***
